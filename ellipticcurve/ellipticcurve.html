<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ECC Message Encryption</title>
</head>
<body>
    <h1>ECC Message Encryption</h1>
    <textarea id="message" rows="4" cols="50" placeholder="Enter your message"></textarea><br>
    <button onclick="encryptMessage()">Encrypt</button><br>
    <textarea id="encrypted" rows="4" cols="50" readonly></textarea>

    <script>
        // NIST P-256 curve parameters
        const p = BigInt("0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF");
        const a = BigInt("0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC");
        const b = BigInt("0x5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B");
        const G = {
            x: BigInt("0x6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296"),
            y: BigInt("0x4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5")
        };
        const n = BigInt("0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551");

        function modInverse(a, m) {
            let [old_r, r] = [a, m];
            let [old_s, s] = [BigInt(1), BigInt(0)];
            let [old_t, t] = [BigInt(0), BigInt(1)];

            while (r !== BigInt(0)) {
                const quotient = old_r / r;
                [old_r, r] = [r, old_r - quotient * r];
                [old_s, s] = [s, old_s - quotient * s];
                [old_t, t] = [t, old_t - quotient * t];
            }

            return (old_s % m + m) % m;
        }

        function addPoints(P, Q) {
            if (P === null) return Q;
            if (Q === null) return P;

            let m;
            if (P.x === Q.x && P.y === Q.y) {
                m = ((BigInt(3) * P.x * P.x + a) * modInverse(BigInt(2) * P.y, p)) % p;
            } else {
                m = ((Q.y - P.y) * modInverse(Q.x - P.x, p)) % p;
            }

            const x = (m * m - P.x - Q.x) % p;
            const y = (m * (P.x - x) - P.y) % p;

            return { x: (x + p) % p, y: (y + p) % p };
        }

        function multiplyPoint(k, P) {
            let R = null;
            let Q = P;

            while (k > BigInt(0)) {
                if (k & BigInt(1)) {
                    R = addPoints(R, Q);
                }
                Q = addPoints(Q, Q);
                k >>= BigInt(1);
            }

            return R;
        }

        function generateKeyPair() {
            const privateKey = BigInt(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER));
            const publicKey = multiplyPoint(privateKey, G);
            return { privateKey, publicKey };
        }

        function sha256(message) {
            const utf8 = new TextEncoder().encode(message);
            return crypto.subtle.digest('SHA-256', utf8).then(hashBuffer => {
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            });
        }

        async function encryptMessage() {
            const message = document.getElementById('message').value;
            const recipientKeyPair = generateKeyPair();
            const senderKeyPair = generateKeyPair();

            const sharedSecret = multiplyPoint(senderKeyPair.privateKey, recipientKeyPair.publicKey);
            const key = await sha256(sharedSecret.x.toString() + sharedSecret.y.toString());

            const encryptedChars = message.split('').map(char => {
                const charCode = char.charCodeAt(0);
                const keyChar = key[charCode % key.length];
                return String.fromCharCode(charCode ^ keyChar.charCodeAt(0));
            });

            const encrypted = btoa(encryptedChars.join(''));
            document.getElementById('encrypted').value = encrypted;
        }
    </script>
</body>
</html>
